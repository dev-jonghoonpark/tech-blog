---
layout: post
title: 운영체제 9장 - 메인 메모리 (3) - 페이징 테이블, 스와핑
categories: [스터디-운영체제]
tags:
  [
    운영체제,
    OS,
    Operating System,
    memory,
    main memory,
    메인 메모리,
    계층적 페이징,
    해시 테이블,
    역 페이지 테이블,
    스와핑,
  ]
date: 2023-12-23 21:40:00 +0900
---

- [운영체제 9장 - 메인 메모리 (1) - 기본](/2023/12/21/os-ch-9-main-memory)
- [운영체제 9장 - 메인 메모리 (2) - 페이징, paging](/2023/12/22/os-ch-9-main-memory-2)

에서 이어지는 글입니다.

---

# 메인 메모리

## 9.4 페이지 테이블의 구조

### 9.4.1 계층적 페이징

현대 컴퓨터는 매우 큰 주소 공간(2^32, 2^64)을 가진다. 이러한 환경에서는 페이지 테이블도 상당히 커진다.

e.g. 32비트 논리 주소 공간을 가진 시스템  
페이지 크기가 4KB(2^12, 2^10가 1K다.) 라면 페이지 테이블은 100만(2^20 = 2^32 / 2^12)개 이상의 항목으로 구성될 것이다.
각 페이지 테이블 항목은 4B(32bit = 8bit \* 4 = 4B)로 구성되기 때문에 각 프로세스는 페이지 테이블만을 위해서도 4MB(2^20 \* 4 = 2^22)의 공간이 필요하게 될 것이다.

이러한 문제를 해결하기 위해 테이블을 여러 개의 작은 조각으로 나눈다.

한 가지 방법은 2단계 페이징 기법(two-level paging scheme)이다. 페이지 테이블 자체가 다시 페이징되게 하는 것이다.

![two-level-page-table-scheme](/assets/images/2023-12-23-os-ch-9-main-memory-3/two-level-page-table-scheme.png)

32bit 에서는 다음과 같이 entry가 구성된다.

![32bit-address-space](/assets/images/2023-12-23-os-ch-9-main-memory-3/32bit-address-space.png)

32bit의 2단계 페이징 구조에서의 구소 변환은 다음과 같이 진행된다.

![address-translation-for-a-two-level-32-bit-paging-architecture](/assets/images/2023-12-23-os-ch-9-main-memory-3/address-translation-for-a-two-level-32-bit-paging-architecture.png)

64bit 에서는 2단계 페이징 기법도 적절하지 못하다. 각 논리 주소를 변환하기 위해 너무 많은 메모리 접근을 필요로 하기 때문에 페이징 단계를 늘려도 비현실적이게 된다.

### 9.4.2 해시 페이지 테이블

주소 공간이 32비트보다 커지면 가상 주소를 해시로 사용하는 해시 페이지 테이블을 많이 쓴다.

해시 테이블의 각 항목은 연결 리스트를 가지고 있다. 해시 값이 충돌이 있을 경우 원소들이 연결되게 된다.

각 원소는 세 개의 필드를 가진다.

1. 가상 페이지 번호
2. 변환되는 페이지 프레임 번호
3. 연결 리스트상의 다음 원소 포인터.

페이지 번호가 해시 함수를 거친 뒤 해시 페이지 테이블에서 연결 리스트를 따라가며 일치하는 노드를 찾는다. 일치하면 그에 대응하는 페이지 프레임 번호를 가져와 물리 주소를 얻는다.

![hashed-page-table](/assets/images/2023-12-23-os-ch-9-main-memory-3/hashed-page-table.png)

64 비트 시스템에서 유용하도록 변경된 클러스터 페이지 테이블도 있다. 해시 페이지 테이블의 각 항목이 한 개의 페이지만 가리키는 것에 반해 클러스터 페이지 테이블의 각 항목은 여러 페이지를 가리킨다.

### 9.4.3 역 페이지 테이블

페이지 테이블의 단점 중 하나는 각 페이지 테이블 항목의 개수가 수백만 개가 될 수도 있다는 것이다. 물리 메모리의 사용을 추적하기 위해 많은 양의 물리 메모리를 소비한다.

이 문제를 해결하는 한 방법이 **역 페이지 테이블(inverted page table)**이다.

![inverted-page-table](/assets/images/2023-12-23-os-ch-9-main-memory-3/inverted-page-table.png)

이 방법은 논리 페이지마다 항목을 가지는 대신 물리 프레임이 대응되는 항목만 테이블에 저장하기 때문에 메모리에서 훨씬 작은 공간을 점유한다.

하지만 페이지 전체를 검색해야할 수도 있다. 탐색이 오래걸리게되면 주소 변환 시간도 늘어난다.
여기에 해시 테이블을 결합하여 사용한다. (이렇게 될 경우 접근마다 해시 테이블을 참조해야 하지만, 해시 테이블이 참조되기 전에 우선 TLB가 참조된다.)

표준 페이징을 사용하면 프로세스마다 고유한 페이지 테이블이 있으므로 여러 가상 주소를 동일한 물리 주소에 매핑할 수 있다. 하지만 이 방법은 역 페이지 테이블과 함께 사용할수는 없다. 열 페이지 테이블의 경우 한 번에 하나의 가상 주소만 공유 물리 주소에 매핑할 수있다.

> **일반 페이지 테이블의 문제**
> 각 프로세스가 자체의 페이지 테이블을 가지는 경우, 메모리에 여러 개의 페이지 테이블이 중복 저장될 수 있습니다. 이는 메모리 사용을 증가시키는 문제가 됩니다.  
> **역페이지 테이블의 해결책**
> 역페이지 테이블은 모든 프로세스에 대한 단일 테이블이므로 중복 저장을 피할 수 있습니다. 각 프로세스는 역페이지 테이블에만 자신의 페이지에 대한 매핑 정보를 저장하면 됩니다. 이는 메모리 사용을 줄이는 효과가 있습니다.

### 9.4.4 Oracle SPARC Solaris

생략

## 9.5 스와핑

프로세스가 실행되기 위해서는 프로세스의 명령어와 데이터가 메모리에 있어야한다.

프로세스 또는 프로세스의 일부분은 실행 중에 임시로 **백업 저장장치(backing store)** 로 내보내어 졌다가 실행을 계속하기 위해 다시 메모리로 되돌아 올 수 있다.

### 9.5.1 기본 스와핑

기본적인 스와핑은 메인 메모리와 백업 저장장치 간에 전체 프로세스를 이동한다.

![standard-swapping-of-two-processes-using-a-disk-as-a-backing-store](/assets/images/2023-12-23-os-ch-9-main-memory-3/standard-swapping-of-two-processes-using-a-disk-as-a-backing-store.png)

백업 저장장치는 일반적으로 빠른 보조저장장치다. 운영체제는 스왑아웃된 프로세스에 대한 메타데이터를 유지해야 메모리로 다시 스왑인될 때 복원될 수 있다.

스와핑을 통해 실제 물리 메모리보다 더 많은 프로세스를 수용할 수 있게된다. 유휴 상태 또는 대부분의 시간을 유휴 상태로 보내는 프로세스가 스와핑에 적합한 후보이다. 스왑된 비활성 프로세스가 다시 활성화되려면 다시 스왑인 하면 된다.

### 9.5.2 페이징에서의 스와핑

위에서 알아본 기본적인 스와핑은 프로세스 전체를 이동시켜야 하고, 이에 걸리는 시간이 엄청나기 때문에 최신 운영체제에서는 더는 사용되지 않는다.

대부분의 시스템들은 프로세스 전체가 아닌 프로세스 페이지를 스왑할 수 있는 변형 스와핑을 사용한다.

**페이지 아웃 연산 (page out)** 은 페이지를 메모리에서 백업 저장장치로 이동시킨다.

반대 방향의 연산을 **페이지 인 (page in)** 이라고 한다.

![swapping-with-paging](/assets/images/2023-12-23-os-ch-9-main-memory-3/swapping-with-paging.png)

페이징에서의 스와핑은 가상 메모리와 함께 잘 동작한다. 이는 10장에서 알아본다.

### 9.5.3 모바일 시스템에서의 스와핑

PC와 서버 환경에서는 대부분 페이지 스와핑을 지원한다. 이와는 대조적으로 모바일 시스템에서는 어떠한 형태의 스와핑도 지원하지 않는 것이 일반적이다.

모바일 장치들은 비휘발성 저장장치로 공간을 많이 차지하는 하드디스크보다 플래시 메모리를 사용한다. 저장 공간이 줄어드는 것이 모바일 운영체제의 설계자가 스와핑을 피하게 되는 여러 이유 중의 하나가 된다.

스와핑을 사용하는 대신 가용 메모리가 정해진 임계값보다 떨어지면 어플리케이션에 할당된 메모리를 자발적으로 반환하도록 요청한다. 코드와 같은 읽기 전용 데이터는 필요에 다라 메인 메모리로부터 제거되고 나중에 플래시 메모리에서 다시 적재할 수 있다.
