---
layout: "post"
title: "[Database] 데이터베이스 복구 알고리즘"
description: "데이터베이스 복구 알고리즘에 대한 포스트에서는 DBMS의 스틸/노스틸 및 포스/노포스 정책을 통해 메모리의 변경 사항을 디\
  스크로 플러시하는 시점을 결정하는 방법을 설명합니다. ARIES 알고리즘은 노스틸/노포스 정책을 기반으로 하며, 리두와 언두 로그를 활용하여 빠\
  른 복구와 동시성을 높이는 방식을 채택합니다. 또한, 퍼지 체크포인트를 통해 더티 페이지를 관리하며, 복구 과정은 분석, 리두, 언두 단계로 나\
  뉘어 데이터베이스를 일관된 상태로 복원합니다. MySQL은 이러한 개념을 참고하여 복구 과정을 수행하는 것으로 보입니다."
categories:
- "스터디-데이터베이스"
tags:
- "Database"
- "internals Database internals"
- "전략"
- "WAL"
- "Force"
- "No-Force"
- "Steal"
- "No-Steal"
- "Redo"
- "Undo"
- "Log"
- "restore"
- "ARIES"
date: "2024-09-01 14:30:00 +0000"
toc: true
image:
  path: "/assets/thumbnails/2024-09-01-database-steal-and-force.jpg"
---

아래 내용들은 Database Internals 에 있는 내용을 정리한 것이다.

## Force 전략 과 Steal 전략

DBMS는 스틸/노스틸 정책과 포스/노포스 정책을 기반으로 메모리에 키시된 변경 사항을 디스크로 플러시하는 시점을 결정한다.
이 정책들은 트랜잭션 언두와 리두 작업과 관련되기 때문에 매우 중요하다. 언두는 포스된 페이지를 롤백하고, 리두는 커밋된 트랜잭션을 다시 수행한다.

| 정책   | 설명                                                                   |
| ------ | ---------------------------------------------------------------------- |
| 스틸   | 트랜잭션이 수정한 페이지를 커밋하기도 전에 플러시하는 것을 허용한다.   |
| 노스틸 | 커밋되지 않은 트랜잭션이 디스크로 플러시되는 것을 허용하지 않는다.     |
| 포스   | 트랜잭션이 수정한 모든 페이지를 커밋하기 전에 플러시한다.              |
| 노포스 | 일부 페이지가 디스크로 플러시 되지 않았더라도 트랜잭션 커밋을 허용한다 |

더티 페이지를 스틸한다 = 메모리에 캐시된 데이터를 디스크로 플러시하고 디스크에서 다른 페이지를 페이징하는 것
더티 페이지를 포스한다 = 커밋 전에 디스크로 플러시하는 것

노스틸 정책을 사용하면 디스크에는 이전 상태의 페이지가 저장돼 있고 로그에는 최신 변경 사항이 저장돼 있기 때문에 리두 로그만 사용해 상태를 복구할 수 있다.
노포스 정책을 사용하면 플러시 시점을 늦추어 더 많은 변경 사항을 버퍼링 할 수 있다.
포스 정책을 사용하면 수정한 페이지는 커밋 전에 플러시되기 때문에 장애 복구 시 트랜잭션의 커밋 결과를 재구성하지 않아도 된다. 하지만 많은 I/O로 인해 트랜잭션 커밋 시간이 증가한다.

### 그러면 MySQL은 어떤 전략을 사용할까? (생각)

MySQL은 리두 로그와 언두 로그를 모두 사용하기 때문에 노포스, 스틸 전략을 기본적으로 사용한다는 것을 알 수 있다.

## ARIES (Algorithms for Recovery and Isolation Exploiting Semantics)

ARIES는 노스틸/노포스 정책 기반의 복구 알고리즘이다. ([위키](https://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics))

ARIES는 빠른 복구를 위해 물리적 리두 로그를 사용하고(변경사항을 빠르게 반영할 수 있음) 일반 작업의 동시성을 높이기 위해 논리적 언두를 사용한다. (페이지에 독립적으로 적용할 수 있음)

복구 시 커밋되지 않은 트랜잭션을 언두하기 전에 데이터베이스 상태를 재구성하기 위해 WAL 레코드를 기반으로 작업을 재수행(repeating history)하고 언두 중에 보상 로그 레코드를 기록한다. (복구 중에도 장애가 발생할 수 있기 때문)

LSN을 이용해 로그 레코드를 식별하고 트랜잭션에서 어떤 페이지를 수정했는지 더티 페이지를 기록한다.

퍼지 체크포인트를 사용한다.

### 퍼지 체크포인트 (Fuzzy checkpoint)

모든 Dirty Page를 디스크로 Flush하지 않고, Dirty Page를 조금씩 디스크로 Flush 하면서 그 위치를 관리하는 방식.
시작 시점의 LSN과 종료 시점의 LSN을 기록한다.

커밋된 트랜잭션들의 모든 수정된 페이지들을 디스크에 플러시 하는 방식은 **샤프 체크포인트(Sharp CHeckpoint)** 라고 한다.

Fuzzy checkpoint 는 시작 LSN부터 종료 LSN까지 REDO를 수행함으로써, 개념적으로 sharp checkpoint 로 변환될 수 있다.

- 관련 글
  - [MySQL Architecture - checkpoint](https://blog.ex-em.com/1700)
  - [how innodb performs a checkpoint](https://github.com/meeeejin/til/blob/master/mysql/how-innodb-performs-a-checkpoint.md)

### 복구 과정

#### 분석 단계

더티 페이지에 대한 정보를 기반으로 리두 단계의 시작 지점을 결정한다.

#### 리두 단계

장애가 발생하기 전까지의 작업을 재수행하여 데이터베이스를 이전 상태로 복원한다.

#### 언두 단계

불완전한 트랜잭션을 롤백하고 데이터베이스를 마지막 일관된 상태로 복원한다.

### MySQL도 ARIES를 사용했을까? (생각)

공식적으로 ARIES를 사용했다는 자료를 찾을 수는 없었다. 하지만 컨셉은 영향을 받았을 것이라고 생각한다.

MySQL의 복구 과정에 대한 자료들을 보았을 때 비슷한 용어들이 사용되었고 비슷한 절차로 진행되는 것으로 이해를 했기 때문에다.
