---
layout: post
title: SOLID 설계 원칙
categories: [스터디-아키텍처]
tags:
  [
    아키텍처,
    SOLID,
    설계,
    단일 책임,
    개방-폐쇄,
    리스코프 치환,
    인터페이스 분리,
    의존성 역전,
    클린 아키텍처,
  ]
date: 2023-10-10 23:30:00 +0900
---

클린 아키텍처 - 로버트 C. 마틴

3부 설계 원칙

- 7장 SRP: 단일 책임 원칙
- 8장 OCP: 개방 폐쇄 원칙
- 9장 LSP: 리스코프 치환 원칙
- 10장 ISP: 인터페이스 분리 원칙
- 11장 DIP: 의존성 역전 원칙

---

# SOLID 원칙 개요

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다. '클래스'라는 단어를 사용했다고 해서 SOLID 원칙이 객체 지향 소프트웨어에만 적용된다는 뜻은 아니다. 여기에서 클래스는 단순히 함수와 데이터를 결합한 집합을 가리킨다. 소프트웨어 시스템은 모두 이러한 집합을 포함한다.

SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는데 있다.

- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

'중간 수준'이라 함은 프로그래머가 이 원칙들을 모듈 수준에서 작업할 때 적용할 수 있다는 뜻이다. 즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는데 도움을 준다.

SOLID 원칙을 개략적으로 설명하자면 다음과 같다.

- **SRP: 단일 책임 원칙 (Single Responsibility Principle)**  
  콘웨이(Conway) 법칙에 따른 따름정리:  
  소프트웨어 시스템이 가질 수 있는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다. 따라서 각 소프트웨어 모듈은 변경의 이유가 단 하나여야만 한다.
- **OCP: 개방 폐쇄 원칙 (Open-Closed Principle)**  
  1980년대 버트란트 마이어(Bertrand Meyer)에 의해 유명해진 원칙이다. 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다는 것이다.
- **LSP: 리스코프 치환 원칙 (Liskov Substitution Principle)**  
  1988년 바바라 리스코프(Barbara Liskov)가 정의한, 하위 타입(subtype)에 관한 유명한 원칙이다. 요약하면, 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다.
- **ISP: 인터페이스 분리 원칙 (Interface Segregation Principle)**  
  소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
- **DIP: 의존성 역전 원칙 (Dependency Inversion Principle)**  
  고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다.

> **콘웨이 법칙**  
> 소프트웨어 구조는 개발 조직의 커뮤니케이션 구조를 닮는다.  
> [콘웨이의 법칙(Conway's law)](https://johngrib.github.io/wiki/Conway-s-law/)

> **따름 정리**  
> 수학에서, 명제나 정리의 따름 정리(-定理, 영어: corollary)는 그 명제나 정리에서 바로 유도되는 명제이다.

# SRP: 단일 책임 원칙

SRP는 이름만 듣는다면 모든 모듈이 단 하나의 일만 해야한다는 의미로 받아들이기 쉽다. 하지만 그것을 의미하는 것은 아니다.

SRP는 아래와 같이 기술되어 왔다.

**단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.**

이 원칙은 아래와 같이 바꿔 말할 수도 있다.

**하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관리자에 대해서만 책임져야 한다.**

여기서 '사용자', '이해관리자' 는 꼭 한명이지는 않다. 두 명 이상이 모인 집단도 포함할 수 있다.
이를 묶어서 **액터** 라고 부르자.

최종적으로는 SRP에 대한 설명은 아래와 같다.

**하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.**

그럼 모듈은 무엇인가? 가장 단순한 정의는 바로 소스 파일이다. 대부분의 경우는 이에 잘 들어맞는다. 하지만 일부 언어와 개발환경에서는 코드를 소스 파일에 저장하지 않는다. 이러한 경우 모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합니다.
'응집된(cohesive)'이라는 단어가 SRP를 암시한다. 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성(cohesive)이다.

이 원칙을 이해하는 가장 좋은 방법은 이 원칙을 위반하는 징후들을 살펴보는 일일 것이다.

## 징후 1. 우발적 중복

![srp violation example](/assets/images/2023-10-10-SOLID-설계-원칙/srp-violation-example.png)

위의 Employee 클래스는 세 가지 메서드 calculatePay(), reportHours(), save()를 가진다.

이 클래스는 SRP를 위반하는데, 이들 세 가지 메서드가 서로 매우 다른 세 명의 액터를 책임지기 때문이다.

- calculatePay() 메서드는 회계팀에서 기능을 정의하며, CFO 보고를 위해 사용한다.
- reportHours() 메서드는 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위해 사용한다.
- save() 메서드는 데이터베이스 관리자가 기능을 정의하고, CTO 보고를 위해 사용한다.

개발자가 이 세 메서드를 Employee라는 단일 클래스에 배치하여 세 액터가 서로 결합되어 버렸다. 이 결합으로 인해 CFO팀에서 결정한 조치가 COO팀이 의존하는 무언가에 영향을 줄 수 있다.

예를 들어 calculatePay() 메서드와 reportHours() 메서드가 초과 근무를 제외한 업무 시간을 계산하는 알고리즘을 공유한다고 해보자. 그리고 개발자는 코드 중복을 피하기 위해 이 알고리즘을 regularHours() 라는 메서드에 넣었다고 해보자.

![srp violation example: shared algorithm](/assets/images/2023-10-10-SOLID-설계-원칙/srp-violation-example-shared-algorithm.png)

여기서 CFO 팀에서 초과 근무를 제외한 업무 시간을 계산하는 방식을 약간 수정하기로 결정했다고 하자. 반면 인사를 담당하는 COO 팀에서는 초과 근무를 제외한 업무 시간을 CFO 팀과는 다른 목적으로 사용하기 때문에, 이 같은 변경을 원하지 않는다고 해보자.

이 변경을 적용하는 업무를 할당받은 개발자는 calculatePay() 메서드가 편의 메서드인 regularHours()를 호출한다는 사실을 발견한다. 하지만 안타깝게도 이 함수가 reportHours() 메서드에서도 호출된다는 사실은 눈치채지 못한다.

개발자는 요청된 변경사항을 적용하고 신중하게 테스트한다. (reportHours에 대한 부분은 생각하지 못하고 calculatePay에 대한 부분만 테스트 할 것이다.) CFO팀은 변경된 메소드가 요청 사항대로 동작하는지 검증하고, 시스템은 배포된다.

하지만 이러한 변경이 벌어지고 있다는 것을 COO 팀에서는 알지 못한다. 따라서 COO 팀에서는 reportHours() 메서드를 통해 생성한 보고서를 여전히 이용하게 된다. 하지만 이 보고서에 포함된 수치들은 엉터리다.

문제가 발견되고 COO는 격노한다. 잘못된 데이터로 인해 수백만 달러의 예산이 지출되었기 때문이다.

우리 모두는 이와 같은 상황을 목격한 경험이 있다. 이러한 문제는 서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문에 발생한다. SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.

## 징후 2: 병합

소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생하리라고 짐작하기는 어려운 일이 아니다. 특히 메서드가 서로 다른 엑터를 책임진다면 병합이 발생할 가능성은 확실히 더 높다.

예를 들어 DBA가 속한 CTO 팀에서 데이터베이스의 Employee 테이블 스키마를 약간 수정하기로 결정했다고 해보자. 이와 동시에 인사 담당자가 속한 COO 팀에서는 reportHours() 메서드의 보고서 포맷을 변경하기로 했다고 해보자.

이들의 변경사항은 서로 충돌한다. 결과적으로 병합이 발생한다.

병합에는 위험이 따른다. 최신 도구는 굉장히 뛰어나지만, 어떤 도구도 병합이 발생하는 모든 경우를 해결할 수는 없다.

이 징후는 많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우에 해당한다. 이 문제에서 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.

이 문제의 해결법은 다양하다. 결론적으로는 메서드를 각기 다른 클래스로 이동시키는 것이다.

가장 확실한 해결책은 데이터와 메서드를 분리하는 방식일 것이다. 즉, 아무런 메서드가 없는 간단한 데이터 구조인 EmployeeData 클래스를 만들어, 세 개의 클래스가 공유하도록 한다.

![employeedata-class-example](/assets/images/2023-10-10-SOLID-설계-원칙/employeedata-class-example.png)

각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만을 포함한다. 세 클래스는 서로의 존재를 몰라야 한다. 따라서 '우연한 중복'을 피할 수 있다.

이 해결책의 단점은 개발자가 세 가지 클래스를 인스턴스화하고 추적해야 한다는 것이다.

이러한 난관에서 빠져나올 때 흔히 쓰는 기법으로는 퍼사드(Facade) 패턴이 있다.

![employeedata-class-example-with-facade](/assets/images/2023-10-10-SOLID-설계-원칙/employeedata-class-example-with-facade.png)

가장 중요한 메서드는 기존의 Employee 클래스에 그대로 유지하고, Employee 클래스의 덜 중요한 나머지 메서드들을 퍼사드로 사용할 수 있다.

![employeedata-class-example-with-facade2](/assets/images/2023-10-10-SOLID-설계-원칙/employeedata-class-example-with-facade2.png)

## 결론

단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 하지만 이보다 상위의 두 수준에서도 다른 형태로 다시 등장한다. 컴포넌트 수준에서는 공통 폐쇄 원칙(common closure principle)이 된다. 아키텍처 수준에서는 아키텍처 경계(architectural boundary)의 생성을 책임지는 변경의 축(axis of change)이 된다.

# OCP: 개방 폐쇄 원칙

개방-폐쇄 원칙(OCP)이라는 용어는 1988년 버트란트 마이어가 만들었다. 의미는 다음과 같다.

**소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.**

다시 말하면 소프트웨어 개체의 행위는 확장할 수 있어야 한지만, 이때 객체를 변경해서는 안 된다.

## 사고실험

재무제표를 웹 페이지로 보여주는 시스템이 있다고 생각해보자. 웹 페이지에 표시되는 데이터는 스크롤할 수 있으며, 음수는 빨간색으로 출력한다.

이해 관계자가 동일한 정보를 보고서 형태로 변환해서 흑백 프린터로 출력할 수 있게 해달라고 요청했다고 해보자. 추가적으로 이 보고서에는 페이지 번호가 매겨져 있어야 하고, 페이지마다 머리글과 바닥글이 있어야 하며, 표의 각 열에는 레이블이 있어야 하고, 음수는 괄호로 감싸야 한다.

이를 위해서는 당연히 새로운 코드를 작성해야 한다. 그렇다면 그 과정에서 원래 있던 코드는 얼마나 수정해야할까?

소프트웨어 아키텍처가 훌륭하다면 변경되는 코드의 양이 최소화된다. 이상적인 변경량은 0이다.

어떻게 좋은 아키텍처를 디자인할 수 있을까? 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(단일 책임 원칙), 이들 요소 사이의 의존성을 체계화함으로써(의존성 역전 원칙) 변경량을 최소화 할 수 있다.

단일 책임 원칙을 적용하면 데이터 흐름을 아래와 같이 만들 수 있다.

![apply srp](/assets/images/2023-10-10-SOLID-설계-원칙/apply-srp.png)

여기서 중요한 포인트는 보고서 생성이 두 개의 책임으로 분리된다는 사실이다. 하나는 보고서용 데이터를 계산하는 책임이며, 나머지 하나는 이 데이터를 웹으로 보여주거나 종이로 프린트하기에 적합한 형태로 표현하는 책임이다.

이렇게 책임을 분리했다면, 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스 코드 의존성도 확실히 조직화해야 한다. 새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장해야 한다.

이러한 목적을 달성하려면 처리 과정을 클래스 단위로 분할하고, 이들 클래스를 이중선으로 표시한 컴포넌트 단위로 구분해야 한다.

![partitioning and separating](/assets/images/2023-10-10-SOLID-설계-원칙/partitioning-and-separating.png)

좌측 상단에서는 controller, 우측 상단에서는 interactor,  
우측 하단에서는 database, 좌측 하단에서는 presenter와 view를 볼 수 있다.

\<I> 로 표시된 클래스는 인터페이스이며, \<DS> 로 표시된 클래스는 데이터 구조다.

화살표가 열려있다면 사용(using) 관계이며, 닫혀있다면 구현(implement) 관계 또는 상속(inheritance) 관계이다.

> <--- : 열린화살표  
> ◁--- : 닫힌화살표

여기서 주목할 점은 모든 의존성이 소스 코드 의존성을 나타낸다는 사실이다. 예를 들어 화살표가 A 클래스에서 B 클래스로 향한다면, A 클래스에서는 B 클래스를 호출하지만 B 클래스에서는 A 클래스를 전혀 호출하지 않음을 뜻한다.

예를들어 FinancialDataMapper는 구현 관계를 통해 FinancialDataGateway를 알고 있지만, FinancialDataGateway는 FinancialDataMapper에 대해 아무것도 알지 못한다.

또 주목할 점은 이중선은 화살표와 오직 한 방향으로만 교차한다는 사실이다. 모든 컴포넌트 관계는 단 방향으로 이루어진다는 뜻이다. 화살표는 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다.

![component relationship](/assets/images/2023-10-10-SOLID-설계-원칙/component-relationship.png)

다시 한번 말하지만, A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다.

Presenter에서 발생한 변경으로부터 Controller를 보호하고자 하였고
View에서 발생한 변경으로부터 Presenter를 보호하고자 한다.
Interactor는 다른 모든 것에서 발생한 변경으로부터 보호하고자 한다.

Interactor는 OCP를 가장 잘 준수할 수 있는 곳에 위치한다. Database, Controller, Presenter, View에서 발생한 어떤 변경도 Interactor에 영향을 주지 않는다.

왜 Interactor가 이처럼 특별한 위치를 차지해야만 하는가? 그 이유는 바로 Interactor가 업무 규칙을 포함하기 때문이다. Interactor는 애플리케이션에서 가장 높은 수준의 정책을 포함한다. (가장 중요한 문제를 담당한다) 그 외의 컴포넌트들은 모두 주변적인 문제를 처리한다.

Interactor 입장에서는 Controller가 부수적이지만, Controller 입장에서는 Presenter와 View에 비해서는 중심적인 문제를 담당한다.
마찬가지로 Presenter 입장에서는 Controller 보다는 부수적 이지만 View보다는 중심적인 문제를 처리한다.

아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다. 컴포넌트 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

## 방향성 제어

클래스 설계를 다시보자. 이 설계는 컴포넌트 간 의존성이 제대로 된 방향으로 향하고 있음을 확실하게 보여주기 위해 다소 복잡하게 되어있다.

예를 들어 FinancialDataGateway 인터페이스는 FinancialReportGenerator와 FinancialDataMapper 사이에 위치하는데, 이는 의존성을 역전시키기 위해서다. FinancialDataGateway 인터페이스가 없었다면, 의존성이 Interactor 컴포넌트에서 Database 컴포넌트로 바로 향하게 된다. FinancialReport Presenter 인터페이스와 2개의 View 인터페이스도 같은 목적을 가진다.

## 정보 은닉

FinancialReportRequester 인터페이스는 방향성 제어와는 다른 목적을 가진다. 이 인터페이스는 FinancialReportController가 Interactor 내부에 대해 너무 많이 알지 못하도록 막기 위해서 존재한다. 만약 이 인터페이스가 없었다면, Controller는 FinancialEntities에 대해 추이 종속성(transitive dependency)을 가지게 된다.

> **추이 종속성(transitive dependency)**  
> 클래스 A가 클래스 B에 의존하고, 다시 클래스 B가 클래스 C에 의존한다면, 클래스 A는 클래스 C에 의존하게 된다. 이를 추이 종속성이라고 부른다.

추이 종속성을 가지게 되면, 소프트웨어 엔티티는 '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다'는 소프트웨어 원칙을 위반하게 된다.

다시 말해서 Controller에서 발생한 변경으로부터 Interactor를 보호하는 일의 우선순위가 가장 높지만, 반대로 Interactor에서 발생한 변경으로부터 Controller도 보호되기를 바란다. 이를 위해 Interactor 내부를 은닉한다.

## 결론

OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나다. OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.

이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.

# LSP: 리스코프 치환 원칙

1988년 바바라 리스코프는 하위 타입을 아래와 같이 정의했다.

**S 타입의 객체 o1과 T 타입 객체 o2가 있을때, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.**

이 개념을 이해하기 위해 몇 가지 예제를 살펴보자

## 상속을 사용하도록 가이드하기

아래와 같은 License 클래스가 있다고 해보자.

![license example](/assets/images/2023-10-10-SOLID-설계-원칙/license-example.png)

이 클래스는 calcFee() 라는 메서드를 가지며, Billing 애플리케이션에서는 이 메서드를 호출한다. License에는 PersonalLicense와 BusinessLicense라는 두 가지 '하위 타입'이 존재한다.

이 설계는 LSP를 준수하는데, Billing 애플리케이션의 행위가 License 하위 타입 중 무엇을 사용하는지에 전혀 의존하지 않기 때문이다. 이들 하위 타입은 모두 License 타입을 치환할 수 있다.

## 정사각형/직사각형 문제

정사각형/직사각형 문제는 LSP를 위반하는 전형적인 문제로 유명한 예시이다.

![square-rectangle-problem](/assets/images/2023-10-10-SOLID-설계-원칙/square-rectangle-problem.png)

이 예제에서 Square는 Rectangle의 하위 타입으로는 적합하지 않다.
Rectangle의 높이와 너비는 서로 독립적으로 변경될 수 있는 반면, Square의 높이와 너비는 반드시 함께 변경되기 때문이다. User는 대화하고 있는 상대가 Rectangle이라고 생각하므로 혼동이 생길 수 있다.

아래의 코드를 보면 혼동의 이유를 알 수 있다.

```java
Rectangle r = ...
r.setW(5);
r.setH(2);
assert(r.area() == 10);
```

이 코드에서 `...` 부분에서 Square를 생성하였다면 assert 문은 실패하게 된다.

이런 형태의 LSP 위반을 막기 위해서는 if문 등을 이용해서 Rectangle이 Square인지를 검사하는 메커니즘을 User에 추가해야 하는데, 이렇게 하면 User의 행위가 사용하는 타입에 의존하게 되므로, 결국 타입을 서로 치환할 수 없게 된다.

## LSP와 아키텍처

객체지향 등장 초창기에 LSP는 상속을 사용하도록 가이드하는 방법 정도로 간주되었다. 하지만 시간이 지나면서 LSP는 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모해왔다.

아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 시스템 아키텍처에서 무슨 일이 일어나는지 관찰하는 것이다.

## LSP 위반 사례

다양한 택시 파견 서비스를 통합하는 애플리케이션을 만들고 있다고 해보자. 고객은 어느 택시업체인지는 신경쓰지 않고 자신의 상황에 가장 적합한 택시를 찾는다. 고객이 이용할 택시를 결정하면, 시스템은 REST 서비스를 통해 선택된 택시를 고객 위치로 파견한다.

택시 파견 REST 서비스의 URI가 운전기사 데이터베이스에 저장되어 있다고 가정해보자. 시스템이 고객에게 알맞은 기사를 선택하면, 해당 기사의 레코드로부터 URI 정보를 얻은 다음, 그 URI 정보를 이용하여 해당 기사를 고객 위치로 파견한다.

예를 들어 택시기사 밥(Bob)의 택시 파견 URI는 다음과 같다. (밥은 purplecab 회사 소속이다.)

```
purplecab.com/driver/Bob
```

시스템은 이 URI에 파견에 필요한 정보를 덧붙인 후, 아래와 같이 PUT 방식으로 호출한다.

```
purplecab.com/driver/Bob
    /pickupAddress/24 Maple St.
    /pickupTime/153
    /destination/ORD
```

이 예제와 같이 처리를 하려면 각 택시업체에서 동일한 REST 인터페이스를 반드시 준수하도록 해야한다.

만약 다른 회사에서 개발하는데 destination 필드를 축약해서 dest 라고 했다고 하자.
이를 처리하려면 예외 처리 로직을 추가해야할 것이다. (if문 같은 걸 이용해서)
아키텍트라면 당연히 시스템을 이런 식으로 구성하고 싶지 않을 것이다. 여러가지 문제를 야기할 것이다. 서로 치환이 되지 않기 때문이다.

## 결론

LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야 한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.

# ISP: 인터페이스 분리 원칙

인터페이스 분리 원칙은 아래 다이어그램에서 그 이름이 유래했다.

![diagram](/assets/images/2023-10-10-SOLID-설계-원칙/diagram.png)

위의 상황에서 User1은 op1만을, User2는 op2만을, User3은 op3만을 사용한다고 가정해 보자. OPS는 정적 타입 언어로 작성된 클래스이다. 이 경우 User1에서는 op2와 op3를 전혀 사용하지 않음에도 User1의 소스 코드는 이 두 메서드에 의존하게 된다. (OPS 클래스에서 op2의 소스코드가 변경되면 User1도 다시 컴파일한 후 새로 배포해야 한다. User1이랑 관련된 부분이 변경된 것이 아닌데도)

이러한 문제는 아래와 같이 오퍼레이션을 인터페이스 단위로 분리하여 해결할 수 있다.

![segregated-diagram](/assets/images/2023-10-10-SOLID-설계-원칙/segregated-diagram.png)

## ISP와 언어

앞의 예제는 언어 타입에 의존한다.
정적 타입 언어는 소스 코드 의존성이 발생하고, 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래된다.
하지만 동적 타입 언어에서는 런타임에 추론이 발생되기 때문에 소스코드 의존성이 없기 때문에 재컴파일과 재배포가 필요 없다.

이러한 사실로 인해 ISP를 아키텍처가 아니라, 언어와 관련된 문제라고 결론내릴 여지가 있다.

## ISP와 아키텍처

하지만 한 걸음 물러서서 살펴보자.
일반적으로 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다.
소스 코드 의존성 뿐 아니라 하지만 고수준인 아키텍처 수준에서도 마찬가지 상황이 발생한다.

![example-in-architecture](/assets/images/2023-10-10-SOLID-설계-원칙/example-in-architecture.png)

위 아키텍처에서 S는 F에 의존하며, F는 다시 D에 의존한다.

이 때, F에서는 불필요한 기능 (따라서 S와는 전혀 상관 없다) 이 D에 포함되어 있다고 가정하자. 만약 그 기능 때문에 D 내부가 변경되면, F를 재배포해야 할 수도 있고, 상황에 따라서 S까지 재배포해야 할지 모른다. 심각한 문제는 F에서는 불필요했던 D의 내부 기능으로 인해 문제가 발생해도 F와 S에 영향을 줄 수 있다는 것이다.

## 결론

무언가에 의존하면 예상치도 못한 문제에 빠질 수 있다.

# DIP: 의존성 역전 원칙

의존성 역전 원칙에서 말하는 '유연성이 극대화된 시스템'이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.

오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻이다. 구체적인 대상에는 절대로 의존해서는 안 된다.

이 아이디어는 비현실적이다. 소프트웨어 시스템이라면 구체적인 많은 장치에 반드시 의존하기 때문이다.

그렇기 때문에 DIP를 논할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다.

우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰(volatile) 구체적인 요소다. 그리고 이 구체적인 요소는 우리가 열심히 개발하는 중이라 자주 변경될 수밖에 없는 모듈들이다.

## 안정화된 추상화

추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 따라서 수정해야 한다. 반대로 구체적인 구현체에 변경이 생기더라도 그 구현체가 구현하는 인터페이스는 항상, 좀 더 정확히 말하면 대다수의 경우 변경될 필요가 없다. 따라서 인터페이스는 구현체보다 변동성이 낮다.

뛰어난 소프트웨어 설계자와 아키텍트라면 인터페이스의 변동성을 낮추기 위해 애쓴다. 인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 찾기 위해 노력한다. 이는 소프트웨어 설계의 기본이다. 즉, 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다.

이 원칙에서 전달하려는 내용은 다음과 같이 매우 구체적인 코딩 실천법으로 요약할 수 있다.

- 변동성이 큰 구체 클래스를 참조하지 말라. 대신 추상 인터페이스를 참조하라. 이 규칙은 언어가 정적 타입이든 동적 타입이든 관계없이 모두 적용된다. 또한 이 규칙은 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리를 사용하도록 강제한다.
- 변동성이 큰 구체 클래스로부터 파생하지 말라. 이 규칙은 이전 규칙의 따름정리이지만, 별도로 언급할 만한 가치가 있다. 정적 타입 언어에서 상속은 소스 코드에 존재하는 모든 관계 중에서 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다. 따라서 상속은 아주 신중하게 사용해야 한다. 동적 타입 언어라면 문제가 덜 되지만, 의존성을 가진다는 사실에는 변함이 없다. 따라서 신중에 신중을 거듭하는 게 가장 현명한 선택이다.
- 구체 함수를 오버라이드 하지 말라. 대체로 구체 함수는 소스 코드 의존성을 필요로 한다. 따라서 구체 함수를 오버라이드 하면 이러한 의존성을 제거할수 없게 되며, 실제로는 그 의존성을 상속하게 된다. 이러한 의존성을 제거하려면, 차라리 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야한다.
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.

## 팩토리

이 규칙들을 준수하려면 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 한다. 이러한 점은 조심하는게 당연한데, 사실상 모든 언어에서 객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생하기 때문이다.

자바 등 대다수의 객체 지향 언어에서 이처럼 바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용하곤 한다.

![use-of-the-abstract-factory-pattern](/assets/images/2023-10-10-SOLID-설계-원칙/use-of-the-abstract-factory-pattern.png)

Application은 Service 인터페이스를 통해 ConcreteImpl을 사용하지만, Application에서는 어떤 식으로든 ConcreteImpl의 인스턴스를 생성해야 한다. ConcreteImpl에 대해 소스 코드 의존성을 만들지 않으면서 이 목적을 이루기 위해 Application은 ServiceFactory 인터페이스의 makeSvc 메서드를 호출한다. 이 메서드는 ServiceFactory로부터 파생된 ServiceFactoryImpl에서 구현된다. 그리고 ServiceFactoryImpl 구현체가 ConcreteImpl의 인스턴스를 생성한 후 Service 타입으로 반환한다.

위 그림에서 곡선은 아키텍처 경계를 뜻한다. 이 곡선은 구체적인 것들로부터 추상적인 것들을 분리한다. 소스 코드 의존성은 해당 곡선과 교차할 때 모두 한 방향, 즉 추상적인 쪽으로 향한다.

곡선은 시스템을 두 가지 컴포넌트로 분리한다. 하나는 추상 컴포넌트이며, 다른 하나는 구체 컴포넌트다. 추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함한다. 구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함한다.

제어흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지른다는 점에 주목하자. 다시 말해 소스 코드 의존성을 제어흐름과는 반대 방향으로 역전된다. 이러한 이유로 이 원칙을 의존성 역전이라고 부른다.

## 구체 컴포넌트

위 그림의 구체 컴포넌트에는 구체적인 의존성이 하나 남아있다. ServiceFactoryImpl 구체 클래스가 ConcreteImpl 구체 클래스에 의존한다.

이는 일반적인 일이다. DIP 위배를 모두 없앨 수는 없다. 하지만 DIP를 위배하는 클래스들을 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과는 분리할 수 있다.

흔히 이 컴포넌트를 메인(Main) 이라고 부르는데, main 함수를 포함하기 때문이다.

위 그림의 예로 들어보면 main 함수는 ServiceFactoryImpl의 인스턴스를 생성한 후, 이 인스턴스를 ServiceFactory 타입으로 전역 변수에 저장할 것이다. 그런 다음 Application은 이 전역 변수를 이용해서 ServiceFactoryImpl의 인스턴스에 접근할 것이다.

## 결론

DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙이다. 위에서 설명한 곡선은 아키텍처 경계가 되며, 의존성은 이 곡선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향한다. 이 규칙을 의존성 규칙 이라 부른다.
